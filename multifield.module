<?php

//  field_attach_delete()
//  field_attach_form()
//  field_attach_form_validate()
//  field_attach_insert()
//  field_attach_load()
//  field_attach_load_revision()
//  field_attach_prepare_view()
//  field_attach_preprocess()
//  field_attach_presave()
//  field_attach_submit()
//  field_attach_update()
//X field_attach_validate()
//  field_attach_view()

/**
 * Implements hook_permission().
 */
function multifield_permission() {
  $info['administer multifield'] = array(
    'title' => t('Administer multifields'),
    'description' => t('Add, edit, or delete multifields.'),
    'restrict access' => TRUE,
  );

  return $info;
}

/**
 * Implements hook_menu().
 */
function multifield_menu() {
  $info['multifield/field-remove-item/ajax'] = array(
    'title' => 'Remove item callback',
    'page callback' => 'multifield_field_widget_remove_item_ajax',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
  );

  return $info;
}

/**
 * Implements hook_entity_info().
 */
function multifield_entity_info() {
  $info['multifield'] = array(
    'label' => t('Multifield'),
    'base table' => 'multifield',
    'fieldable' => TRUE,
    // Mark this as a configuratoin entity type to prevent other modules from
    // assuming they can do stuff with this entity type.
    'configuration' => TRUE,
    'bundle keys' => array(
      'bundle' => 'machine_name',
    ),
    'entity keys' => array(
      'id' => 'id',
      'bundle' => 'type',
    ),
  );

  // Bundles must provide a human readable name so we can create help and error
  // messages, and the path to attach Field admin pages to.
  foreach (multifield_load_all() as $machine_name => $multifield) {
    $info['multifield']['bundles'][$machine_name] = array(
      'label' => $multifield->label,
      'admin' => array(
        'path' => 'admin/structure/multifield/list/%multifield',
        'real path' => 'admin/structure/multifield/list/' . $machine_name,
        'bundle argument' => 4,
        'access arguments' => array('administer multifield'),
      ),
    );
  }

  return $info;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function multifield_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'export_ui') {
    return 'plugins/' . $plugin;
  }
}

function multifield_load($name) {
  ctools_include('export');
  return ctools_export_crud_load('multifield', $name);
}

function multifield_load_all() {
  ctools_include('export');
  return ctools_export_crud_load_all('multifield');
}

function multifield_load_all_enabled() {
  $multifields = multifield_load_all();
  foreach ($multifields as $machine_name => $multifield) {
    if (!empty($multifield->disabled)) {
      unset($multifields[$machine_name]);
    }
  }
  return $multifields;
}

function multifield_save($multifield) {
  //$server->is_new = empty($server->sid);
  //module_invoke_all('redmine_server_presave', $server);
  ctools_include('export');
  ctools_export_crud_save('multifield', $multifield);
}

function multifield_type_save($multifield) {
  $return = NULL;
  module_invoke_all('multifield_type_presave', $multifield);

  if ($multifield->export_type & EXPORT_IN_DATABASE) {
    // Existing record.
    $return = drupal_write_record('multifield', $multifield, array('machine_name'));
    module_invoke_all('mulifield_type_update', $multifield);
  }
  else {
    $multifield->export_type = EXPORT_IN_DATABASE;
    $return = drupal_write_record('multifield', $multifield, array());
    module_invoke_all('multifield_type_insert', $multifield);
    field_attach_create_bundle('multifield', $multifield->machine_name);
  }

  multifield_type_cache_clear();
  return $return;
}

/**
 * Implements hook_multifield_type_insert().
 *
 * This is horrible hack to fix that users should be redirected to the
 * 'Manage Fields' tab after creating a new multifield.
 */
function multifield_multifield_type_insert($multifield) {
  if ($_GET['q'] == 'admin/structure/multifield/add') {
    $_GET['destination'] = 'admin/structure/multifield/list/' . $multifield->machine_name . '/fields';
  }
}

function multifield_type_access($op, $multifield) {
  if ($op == 'edit' || $op == 'delete') {

  }
}

function multifield_type_get_fields($multifield = NULL) {
  $fields = array();
  $map = field_info_field_map();
  foreach ($map as $field_name => $field) {
    if (!empty($multifield)) {
      if ($field['type'] == $multifield->machine_name) {
        $fields[$field_name] = $field_name;
      }
    }
    else {
      if (multifield_load($field['type'])) {
        $fields[$field_name] = $field_name;
      }
    }
  }
  return $fields;
}

function multifield_delete($name) {
  if ($multifield = multifield_load($name)) {
    ctools_include('export');
    return ctools_export_crud_delete('multifield', $multifield);
  }
}

function multifield_type_delete($multifield) {
  $machine_name = is_object($multifield) ? $multifield->machine_name : $multifield;

  module_invoke_all('multifield_type_delete', $multifield);

  db_delete('multifield')
    ->condition('machine_name', $machine_name)
    ->execute();

  field_attach_delete_bundle('multifield', $machine_name);
  multifield_type_cache_clear();
}

function multifield_type_cache_clear() {
  //entity_info_cache_clear();
  field_info_cache_clear();
  //variable_set('menu_rebuild_needed', TRUE);
}

function multifield_field_machine_name_exists($name) {
  return field_info_field_types($name) || multifield_load($name);
}

/**
 * Implements hook_field_info().
 */
function multifield_field_info() {
  $info = array();
  $multifields = multifield_load_all_enabled();
  foreach ($multifields as $machine_name => $multifield) {
    if (multifield_field_get_field_names($machine_name)) {
      $info[$machine_name] = array(
        'label' => $multifield->label,
        'description' => $multifield->description,
        'default_widget' => 'multifield_default',
        'default_formatter' => 'multifield_default',
      );
    }
  }
  return $info;
}

/**
 * Implements hook_field_widget_info().
 */
function multifield_field_widget_info() {
  $info = array();
  $multifields = multifield_load_all_enabled();

  if (!empty($multifields)) {
    $info['multifield_default'] = array(
      'label' => t('Default'),
      'field types' => array_keys($multifields),
    );
  }

  return $info;
}

function multifield_field_get_field_names($machine_name = NULL) {
  $fields = &drupal_static(__FUNCTION__);

  if (!isset($fields)) {
    foreach (field_info_field_map() as $field_name => $field) {
      if (!empty($field['bundles']['multifield'])) {
        foreach ($field['bundles']['multifield'] as $bundle) {
          if (!isset($fields[$bundle])) {
            $fields[$bundle] = array();
          }
          $fields[$bundle][] = $field_name;
        }
      }
    }
  }

  if (isset($machine_name)) {
    return !empty($fields[$machine_name]) ? $fields[$machine_name] : array();
  }
  else {
    return $fields;
  }
}

/**
 * Implements hook_field_load().
 */
function multifield_field_load($entity_type, $entities, $field, $instances, $langcode, &$items, $age) {
  foreach (multifield_field_get_field_names($field['type']) as $field_name) {
    $subfield = field_info_field($field_name);
    foreach (array_keys($subfield['columns']) as $column) {
      foreach ($entities as $id => $entity) {
        foreach ($items[$id] as $delta => $item) {
          if (array_key_exists($field_name . '_' . $column, $item)) {
            $items[$id][$delta][$field_name][LANGUAGE_NONE][0][$column] = $item[$field_name . '_' . $column];
            unset($items[$id][$delta][$field_name . '_' . $column]);
          }
        }
      }
    }

    // Once the subfields have been imploded into a proper structure, we need
    // to filter out 'empty' values.
    foreach (array_keys($entities) as $id) {
      foreach ($items[$id] as $delta => $item) {
        if (!empty($item[$field_name][LANGUAGE_NONE])) {
          $items[$id][$delta][$field_name][LANGUAGE_NONE] = _field_filter_items($subfield, $item[$field_name][LANGUAGE_NONE]);
        }
      }
    }
  }

  $pseudo_entities = array();
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => &$item) {
      $pseudo_entity = _multifield_field_item_to_entity($field['type'], $item, TRUE);
      $pseudo_entities[$pseudo_entity->id] = $pseudo_entity;
      $item['#pseudo_entity'] = $pseudo_entity;
    }
  }

  // Invoke field-type module's hook_field_load().
  $options = array();
  $null = NULL;
  _field_invoke_multiple('load', 'multifield', $pseudo_entities, $age, $null, $options);

  // Invoke hook_field_attach_load(): let other modules act on loading the
  // entity.
  module_invoke_all('field_attach_load', 'multifield', $pseudo_entities, $age, $options);
}

function multifield_filter_empty_subfields($items, $machine_name) {
  foreach (multifield_field_get_field_names($machine_name) as $field_name) {
    if (!empty($items[$field_name])) {
      $field = field_info_field($field_name);
      $items = _field_filter_items($subfield, $items);
    }
  }
  return $item;
}

/**
 * Implements hook_field_validate().
 */
function multifield_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    $pseudo_entity = _multifield_field_item_to_entity($field['type'], $item);
    field_attach_validate('multifield', $pseudo_entity);
    $items[$delta] = _multifield_field_entity_to_item($pseudo_entity);
  }
}

/**
 * Implements hook_field_presave().
 */
function multifield_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  // Run each sub-field through hook_field_presave().
  foreach ($items as $delta => $item) {
    $pseudo_entity = _multifield_field_item_to_entity($field['type'], $item);
    field_attach_presave('multifield', $pseudo_entity);
    $items[$delta] = _multifield_field_entity_to_item($pseudo_entity);
  }

  // Serialize the multifield values into separate columns for saving into the
  // field table.
  foreach (field_info_instances('multifield', $field['type']) as $subfield_name => $subfield_instance) {
    $subfield = field_info_field($subfield_name);
    foreach ($items as $delta => $item) {
      if (!empty($item[$subfield_name][LANGUAGE_NONE])) {
        foreach ($item[$subfield_name][LANGUAGE_NONE][0] as $column => $value) {
          if (isset($subfield['columns'][$column])) {
            $items[$delta][$subfield_name . '_' . $column] = $value;
          }
        }
      }
      else {
        foreach ($subfield['columns'] as $column => $details) {
          $items[$delta][$subfield_name . '_' . $column] = isset($details['default']) ? $details['default'] : NULL;
        }
      }
    }
  }
}

function multifield_field_attach_submit($entity_type, $entity, $form, $form_state) {
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  foreach (field_info_instances($entity_type, $bundle) as $field_name => $instance) {
    $field = field_info_field($field_name);
    if ($multifield = multifield_load($field['type']) && !empty($entity->{$field_name})) {
      foreach ($entity->{$field_name} as $langcode => &$items) {
        foreach ($items as $delta => $item) {
          $pseudo_entity = _multifield_field_item_to_entity($field['type'], $item);
          //field_attach_submit('multifield', $pseudo_entity, $form, $form_state);
          _field_invoke_default('submit', 'multifield', $pseudo_entity, $form, $form_state);
          $items[$delta] = _multifield_field_entity_to_item($pseudo_entity);
        }
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 */
function multifield_field_is_empty($item, $field) {
  $instances = field_info_instances('multifield', $field['type']);
  foreach ($instances as $field_name => $instance) {
    if (!empty($item[$field_name])) {
      $subfield = field_info_field($field_name);
      foreach ($item[$field_name] as $langcode => $subfield_items) {
        $item[$field_name][$langcode] = _field_filter_items($subfield, $subfield_items);
      }
      $item[$field_name] = array_filter($item[$field_name]);
    }
  }
  return !array_filter(array_intersect_key($item, $instances));
}

/**
 * Implements hook_field_widget_form().
 */
function multifield_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $item = isset($items[$delta]) ? $items[$delta] : array();

  $element['#parents'] = array_merge($element['#field_parents'], array($element['#field_name'], $element['#language'], $element['#delta']));

  // @todo Can't we rely on $item['#pseudo_entity'] here?
  $pseudo_entity = _multifield_field_item_to_entity($field['type'], $item);

  // Rather than calling field_attach_form() here, we have to limit these
  // sub-field widgets to only one cardinality value. So manually invoke
  // field_default_form() for each one.
  foreach (field_info_instances('multifield', $field['type']) as $field_name => $instance) {
    $subfield = field_info_field($field_name);
    $subfield['cardinality'] = 1;
    if ($instance['required'] && $delta > 0) {
      $instance['required'] = 0;
    }
    $subitems = isset($pseudo_entity->{$field_name}[LANGUAGE_NONE]) ? $pseudo_entity->{$field_name}[LANGUAGE_NONE] : array();
    $element += field_default_form('multifield', $pseudo_entity, $subfield, $instance, $langcode, $subitems, $element, $form_state, 0);
  }
  //field_attach_form('multifield', $pseudo_entity, $element, $form_state, $langcode);

  // If this multifield itself has a cardinality of one value, and this is not
  // being used for the field default value form, then set the wrapping element
  // to be a fieldset for display/grouping purposes.
  if ($field['cardinality'] == 1 && !empty($element['#entity'])) {
    $element['#type'] = 'fieldset';
  }

  $element['actions'] = array(
    '#type' => 'actions',
    //'#attached' => array(
    //  'css' => array(
    //    drupal_get_path('module', 'multifield') . '/multifield.field.css' => array(),
    //  ),
    //),
  );
  $element['actions']['remove_button'] = array(
    '#type' => 'submit',
    '#value' => t('Remove'),
    '#name' => implode('_', $element['#parents']) . '_remove_button',
    '#delta' => $delta,
    '#submit' => array('multifield_field_widget_remove_item_submit'),
    '#limit_validation_errors' => array(),
    '#ajax' => array(
      'path' => 'multifield/field-remove-item/ajax',
      'effect' => 'fade',
    ),
    '#attributes' => array(
      'class' => array('remove-button', 'delta-' . $delta),
    ),
    '#access' => $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED,
  );

  return $element;
}

/**
 * Page callback to handle AJAX for removing a multifield item.
 *
 * Copied from field_collection_remove_js().
 *
 * This is a direct page callback. The actual job of deleting the item is
 * done in the submit handler for the button, so all we really need to
 * do is process the form and then generate output. We generate this
 * output by doing a replace command on the id of the entire form element.
 */
function multifield_field_widget_remove_item_ajax() {
  require_once DRUPAL_ROOT . '/includes/form.inc';

  // drupal_html_id() very helpfully ensures that all html IDS are unique
  // on a page. Unfortunately what it doesn't realize is that the IDs
  // we are generating are going to replace IDs that already exist, so
  // this actually works against us.
  if (isset($_POST['ajax_html_ids'])) {
    unset($_POST['ajax_html_ids']);
  }

  list($form, $form_state) = ajax_get_form();
  drupal_process_form($form['#form_id'], $form, $form_state);

  // Get the information on what we're removing.
  $button = $form_state['triggering_element'];
  // Go two levels up in the form, to the whole widget.
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -4));
  // Now send back the proper AJAX command to replace it.
  $return = array(
    '#type' => 'ajax',
    '#commands' => array(
      ajax_command_replace('#' . $element['#id'], drupal_render($element))
    ),
  );

  // Because we're doing this ourselves, messages aren't automatic. We have
  // to add them.
  $messages = theme('status_messages');
  if ($messages) {
    $return['#commands'][] = ajax_command_prepend('#' . $element['#id'], $messages);
  }

  return $return;
}

/**
 * Submit callback to remove an item from the field UI multiple wrapper.
 *
 * Copied from field_collection_remove_submit()
 *
 * When a remove button is submitted, we need to find the item that it
 * referenced and delete it. Since field UI has the deltas as a straight
 * unbroken array key, we have to renumber everything down. Since we do this
 * we *also* need to move all the deltas around in the $form_state['values']
 * and $form_state['input'] so that user changed values follow. This is a bit
 * of a complicated process.
 */
function multifield_field_widget_remove_item_submit($form, &$form_state) {
  $button = $form_state['triggering_element'];
  $delta = $button['#delta'];

  // Where in the form we'll find the parent element.
  $address = array_slice($button['#array_parents'], 0, -3);

  // Go one level up in the form, to the widgets container.
  $parent_element = drupal_array_get_nested_value($form, $address);
  $field_name = $parent_element['#field_name'];
  $langcode = $parent_element['#language'];
  $parents = $parent_element['#field_parents'];

  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);

  // Go ahead and renumber everything from our delta to the last
  // item down one. This will overwrite the item being removed.
  for ($i = $delta; $i <= $field_state['items_count']; $i++) {
    $old_element_address = array_merge($address, array($i + 1));
    $new_element_address = array_merge($address, array($i));

    $moving_element = drupal_array_get_nested_value($form, $old_element_address);
    $moving_element_value = drupal_array_get_nested_value($form_state['values'], $old_element_address);
    $moving_element_input = drupal_array_get_nested_value($form_state['input'], $old_element_address);

    // Tell the element where it's being moved to.
    $moving_element['#parents'] = $new_element_address;

    // Move the element around.
    form_set_value($moving_element, $moving_element_value, $form_state);
    drupal_array_set_nested_value($form_state['input'], $moving_element['#parents'], $moving_element_input);
  }

  // Then remove the last item. But we must not go negative.
  if ($field_state['items_count'] > 0) {
    $field_state['items_count']--;
  }

  // Fix the weights. Field UI lets the weights be in a range of
  // (-1 * item_count) to (item_count). This means that when we remove one,
  // the range shrinks; weights outside of that range then get set to
  // the first item in the select by the browser, floating them to the top.
  // We use a brute force method because we lost weights on both ends
  // and if the user has moved things around, we have to cascade because
  // if I have items weight weights 3 and 4, and I change 4 to 3 but leave
  // the 3, the order of the two 3s now is undefined and may not match what
  // the user had selected.
  $input = drupal_array_get_nested_value($form_state['input'], $address);
  // Sort by weight
  uasort($input, '_field_sort_items_helper');

  // Reweight everything in the correct order.
  $weight = -1 * $field_state['items_count'];
  foreach ($input as $key => $item) {
    if ($item) {
      $input[$key]['_weight'] = $weight++;
    }
  }

  drupal_array_set_nested_value($form_state['input'], $address, $input);
  field_form_set_state($parents, $field_name, $langcode, $form_state, $field_state);

  $form_state['rebuild'] = TRUE;
}

function multifield_widget_value($element, $input = FALSE, $form_state) {
  //dpm($element);
  //dpm($input);
  //dpm($form_state);
  if ($input) {
  }

  return array();
}

/**
 * Implements hook_field_formatter_view().
 */
function multifield_field_formatter_info() {
  $info = array();
  $multifields = multifield_load_all_enabled();

  if (!empty($multifields)) {
    $info['multifield_default'] = array(
      'label' => t('Default'),
      'field types' => array_keys($multifields),
      'settings' => array(
        'view_mode' => 'default',
      ),
    );
  }

  return $info;
}

/**
 * Implements hook_field_formatter_settings().
 */
function multifield_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $entity_info = entity_get_info('multifield');
  $options = array();
  foreach ($entity_info['view modes'] as $view_mode_name => $view_mode) {
    $options[$view_mode_name] = $view_mode['label'];
  }

  $element['view_mode'] = array(
    '#type' => 'select',
    '#title' => t('View mode'),
    '#options' => array('default' => t('Default')) + $options,
    '#default_value' => $settings['view_mode'],
    '#required' => TRUE,
  );

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function multifield_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $entity_info = entity_get_info('multifield');
  $view_mode_label = $settings['view_mode'] == 'default' ? t('Default') : $entity_info['view modes'][$settings['view_mode']]['label'];

  $summary = t('View mode: @view-mode', array('@view-mode' => $view_mode_label));

  return $summary;
}

/**
 * Implements hook_field_prepare_view().
 */
function multifield_field_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items) {
  $pseudo_entities = array();
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => &$item) {
      $pseudo_entity = _multifield_field_item_to_entity($field['type'], $item);
      $pseudo_entity->delta = $delta;
      $pseudo_entity->parent_id = $id;
      $pseudo_entities[$pseudo_entity->id] = $pseudo_entity;
    }
  }
  field_attach_prepare_view('multifield', $pseudo_entities, NULL, $langcode);
  foreach ($pseudo_entities as $pseudo_entity) {
    $items[$pseudo_entity->parent_id][$pseudo_entity->delta] = _multifield_field_entity_to_item($pseudo_entity);
  }
}

/**
 * Implements hook_field_formatter_view().
 */
function multifield_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  foreach ($items as $delta => $item) {
    $element[$delta] = field_attach_view('multifield', $item['#pseudo_entity'], $settings['view_mode'], $langcode);
  }

  return $element;
}

function _multifield_field_item_to_entity($machine_name, array &$item, $reference = FALSE) {
  $seen_ids = &drupal_static(__FUNCTION__, array());
  do {
    $id = mt_rand();
  }
  while (isset($seen_ids[$id]));
  $seen_ids[$id] = TRUE;

  $entity = new stdClass();
  $entity->id = $id;
  $entity->type = $machine_name;
  foreach ($item as $field => $values) {
    if ($reference) {
      $entity->{$field} = &$item[$field];
    }
    else {
      $entity->{$field} = $item[$field];
    }
  }

  return $entity;
}

function _multifield_field_entity_to_item($pseudo_entity) {
  $item = (array) $pseudo_entity;
  $item = array_intersect_key($item, field_info_instances('multifield', $pseudo_entity->type));
  $item['#pseudo_entity'] = $pseudo_entity;
  return $item;
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_overview_form().
 */
function multifield_form_field_ui_field_overview_form_alter(&$form, &$form_state) {
  // Prevent multifields from being added to multifields themselves.
  if ($form['#entity_type'] == 'multifield') {
    $form['fields']['_add_new_field']['type']['#options'] = array_diff_key($form['fields']['_add_new_field']['type']['#options'], multifield_load_all());
    $form['fields']['_add_existing_field']['field_name']['#options'] = array_diff_key($form['fields']['_add_existing_field']['field_name']['#options'], multifield_type_get_fields());
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_edit_form().
 */
function multifield_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  // Show a notice that multifield subfields have a cardinality of one value
  // enforced in the widget.
  if ($form['#instance']['entity_type'] == 'multifield') {
    $form['field']['cardinality']['#disabled'] = TRUE;
    $form['field']['cardinality']['#field_prefix'] = '<div class="messages warning">' . t('Field cardinality in multifields is limited to one value despite this setting.') . '</div>';
  }
}

/**
 * Implements hook_views_data_alter().
 */
function multifield_views_data_alter(array &$data) {
  // Remove any references to the fake multifield table.
  unset($data['multifield']);
  unset($data['entity_multifield']);
  unset($data['views_entity_multifield']);
  foreach ($data as &$table) {
    unset($table['table']['join']['multifield']);
    unset($table['table']['default_relationship']['multifield']);
  }
}
