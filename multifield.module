<?php

//  field_attach_delete()
//  field_attach_form()
//  field_attach_form_validate()
//  field_attach_insert()
//  field_attach_load()
//  field_attach_load_revision()
//  field_attach_prepare_view()
//  field_attach_preprocess()
//  field_attach_presave()
//  field_attach_submit()
//  field_attach_update()
//X field_attach_validate()
//  field_attach_view()

require_once dirname(__FILE__) . '/multifield.field.inc';

/**
 * Implements hook_permission().
 */
function multifield_permission() {
  $info['administer multifield'] = array(
    'title' => t('Administer multifields'),
    'description' => t('Add, edit, or delete multifields.'),
    'restrict access' => TRUE,
  );

  return $info;
}

/**
 * Implements hook_menu().
 */
function multifield_menu() {
  $info['multifield/field-remove-item/ajax'] = array(
    'title' => 'Remove item callback',
    'page callback' => 'multifield_field_widget_remove_item_ajax',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file' => 'multifield.field.inc',
  );

  return $info;
}

/**
 * Implements hook_entity_info().
 */
function multifield_entity_info() {
  $info['multifield'] = array(
    'label' => t('Multifield'),
    'base table' => 'multifield',
    'fieldable' => TRUE,
    // Mark this as a configuratoin entity type to prevent other modules from
    // assuming they can do stuff with this entity type.
    'configuration' => TRUE,
    'bundle keys' => array(
      'bundle' => 'machine_name',
    ),
    'entity keys' => array(
      'id' => 'id',
      'bundle' => 'type',
    ),
  );

  // Bundles must provide a human readable name so we can create help and error
  // messages, and the path to attach Field admin pages to.
  foreach (multifield_load_all() as $machine_name => $multifield) {
    $info['multifield']['bundles'][$machine_name] = array(
      'label' => $multifield->label,
      'admin' => array(
        'path' => 'admin/structure/multifield/list/%multifield',
        'real path' => 'admin/structure/multifield/list/' . $machine_name,
        'bundle argument' => 4,
        'access arguments' => array('administer multifield'),
      ),
    );
  }

  return $info;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function multifield_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'export_ui') {
    return 'plugins/' . $plugin;
  }
}

function multifield_load($name) {
  ctools_include('export');
  return ctools_export_crud_load('multifield', $name);
}

function multifield_load_all() {
  ctools_include('export');
  return ctools_export_crud_load_all('multifield');
}

function multifield_load_all_enabled() {
  $multifields = multifield_load_all();
  foreach ($multifields as $machine_name => $multifield) {
    if (!empty($multifield->disabled)) {
      unset($multifields[$machine_name]);
    }
  }
  return $multifields;
}

function multifield_save($multifield) {
  //$server->is_new = empty($server->sid);
  //module_invoke_all('redmine_server_presave', $server);
  ctools_include('export');
  ctools_export_crud_save('multifield', $multifield);
}

function multifield_type_save($multifield) {
  $return = NULL;
  module_invoke_all('multifield_type_presave', $multifield);

  if ($multifield->export_type & EXPORT_IN_DATABASE) {
    // Existing record.
    $return = drupal_write_record('multifield', $multifield, array('machine_name'));
    module_invoke_all('mulifield_type_update', $multifield);
  }
  else {
    $multifield->export_type = EXPORT_IN_DATABASE;
    $return = drupal_write_record('multifield', $multifield, array());
    module_invoke_all('multifield_type_insert', $multifield);
    field_attach_create_bundle('multifield', $multifield->machine_name);
  }

  multifield_type_cache_clear();
  return $return;
}

/**
 * Implements hook_multifield_type_insert().
 *
 * This is horrible hack to fix that users should be redirected to the
 * 'Manage Fields' tab after creating a new multifield.
 */
function multifield_multifield_type_insert($multifield) {
  if ($_GET['q'] == 'admin/structure/multifield/add') {
    $_GET['destination'] = 'admin/structure/multifield/list/' . $multifield->machine_name . '/fields';
  }
}

function multifield_type_access($op, $multifield) {
  if ($op == 'edit' || $op == 'delete') {

  }
}

function multifield_type_get_fields($multifield = NULL) {
  $fields = array();
  $map = field_info_field_map();
  foreach ($map as $field_name => $field) {
    if (!empty($multifield)) {
      if ($field['type'] == $multifield->machine_name) {
        $fields[$field_name] = $field_name;
      }
    }
    else {
      if (multifield_load($field['type'])) {
        $fields[$field_name] = $field_name;
      }
    }
  }
  return $fields;
}

function multifield_delete($name) {
  if ($multifield = multifield_load($name)) {
    ctools_include('export');
    return ctools_export_crud_delete('multifield', $multifield);
  }
}

function multifield_type_delete($multifield) {
  $machine_name = is_object($multifield) ? $multifield->machine_name : $multifield;

  module_invoke_all('multifield_type_delete', $multifield);

  db_delete('multifield')
    ->condition('machine_name', $machine_name)
    ->execute();

  field_attach_delete_bundle('multifield', $machine_name);
  multifield_type_cache_clear();
}

function multifield_type_cache_clear() {
  //entity_info_cache_clear();
  field_info_cache_clear();
  //variable_set('menu_rebuild_needed', TRUE);
}

function multifield_field_machine_name_exists($name) {
  return field_info_field_types($name) || multifield_load($name);
}

function multifield_field_get_field_names($machine_name = NULL) {
  $fields = &drupal_static(__FUNCTION__);

  if (!isset($fields)) {
    foreach (field_info_field_map() as $field_name => $field) {
      if (!empty($field['bundles']['multifield'])) {
        foreach ($field['bundles']['multifield'] as $bundle) {
          if (!isset($fields[$bundle])) {
            $fields[$bundle] = array();
          }
          $fields[$bundle][] = $field_name;
        }
      }
    }
  }

  if (isset($machine_name)) {
    return !empty($fields[$machine_name]) ? $fields[$machine_name] : array();
  }
  else {
    return $fields;
  }
}

function _multifield_field_item_to_entity($machine_name, array $item) {
  $pseudo_entity = new stdClass();
  $pseudo_entity->id = _multifield_generate_unique_id();
  $pseudo_entity->type = $machine_name;
  foreach ($item as $field => $values) {
    $pseudo_entity->{$field} = $item[$field];
  }
  return $pseudo_entity;
}

function _multifield_generate_unique_id() {
  $seen_ids = &drupal_static(__FUNCTION__, array());
  do {
    $id = mt_rand();
  }
  while (isset($seen_ids[$id]));
  $seen_ids[$id] = TRUE;

  return $id;
}

function _multifield_field_entity_to_item($pseudo_entity) {
  $item = (array) $pseudo_entity;
  $item = array_intersect_key($item, field_info_instances('multifield', $pseudo_entity->type));
  //$item['#pseudo_entity'] = $pseudo_entity;
  return $item;
}

function multifield_item_unserialize(&$item, $delta, $multifield) {
  foreach (multifield_field_get_field_names($multifield['type']) as $subfield_name) {
    $subfield = field_info_field($subfield_name);
    foreach (array_keys($subfield['columns']) as $column) {
      if (array_key_exists($subfield_name . '_' . $column, $item)) {
        $item[$subfield_name][LANGUAGE_NONE][0][$column] = $item[$subfield_name . '_' . $column];
        unset($item[$subfield_name . '_' . $column]);
      }
    }
  }
}

function multifield_item_serialize(&$item, $delta, $multifield) {
  // Serialize the multifield values into separate columns for saving into the
  // field table.
  foreach (field_info_instances('multifield', $multifield['type']) as $subfield_name => $subfield_instance) {
    $subfield = field_info_field($subfield_name);
    foreach ($subfield['columns'] as $column => $details) {
      if (isset($item[$subfield_name][LANGUAGE_NONE][0][$column])) {
        // We need to assign this value by reference because
        // $items[$delta][$subfield_name] could be modified in
        // multifield_field_insert() or multifield_field_update().
        $item[$subfield_name . '_' . $column] = &$item[$subfield_name][LANGUAGE_NONE][0][$column];
      }
      else {
        // @see field_sql_storage_field_storage_write()
        $item[$subfield_name . '_' . $column] = isset($details['default']) ? $details['default'] : NULL;
      }
    }
    //unset($item[$subfield_name]);
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_overview_form().
 */
function multifield_form_field_ui_field_overview_form_alter(&$form, &$form_state) {
  // Prevent multifields from being added to multifields themselves.
  if ($form['#entity_type'] == 'multifield') {
    $form['fields']['_add_new_field']['type']['#options'] = array_diff_key($form['fields']['_add_new_field']['type']['#options'], multifield_load_all());
    $form['fields']['_add_existing_field']['field_name']['#options'] = array_diff_key($form['fields']['_add_existing_field']['field_name']['#options'], multifield_type_get_fields());
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_edit_form().
 */
function multifield_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  // Show a notice that multifield subfields have a cardinality of one value
  // enforced in the widget.
  if ($form['#instance']['entity_type'] == 'multifield') {
    $form['field']['cardinality']['#disabled'] = TRUE;
    $form['field']['cardinality']['#field_prefix'] = '<div class="messages warning">' . t('Field cardinality in multifields is limited to one value despite this setting.') . '</div>';
  }
}

/**
 * Implements hook_views_data_alter().
 */
function multifield_views_data_alter(array &$data) {
  // Remove any references to the fake multifield table.
  unset($data['multifield']);
  unset($data['entity_multifield']);
  unset($data['views_entity_multifield']);
  foreach ($data as &$table) {
    unset($table['table']['join']['multifield']);
    unset($table['table']['default_relationship']['multifield']);
  }
}
