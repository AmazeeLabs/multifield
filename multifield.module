<?php

//  field_attach_delete()
//  field_attach_form()
//  field_attach_form_validate()
//  field_attach_insert()
//  field_attach_load()
//  field_attach_load_revision()
//  field_attach_prepare_view()
//  field_attach_preprocess()
//  field_attach_presave()
//  field_attach_submit()
//  field_attach_update()
//X field_attach_validate()
//  field_attach_view()

/**
 * Implements hook_permission().
 */
function multifield_permission() {
  $info['administer multifield'] = array(
    'title' => t('Administer multifields'),
    'description' => t('Add, edit, or delete multifields.'),
    'restrict access' => TRUE,
  );

  return $info;
}

function multifield_menu() {
}

/**
 * Implements hook_entity_info().
 */
function multifield_entity_info() {
  $info['multifield'] = array(
    'label' => t('Multifield'),
    'fieldable' => TRUE,
    'configuration' => TRUE,
    'bundle keys' => array(
      'bundle' => 'machine_name',
    ),
    'entity keys' => array(
      'id' => 'id',
      'bundle' => 'type',
    ),
  );

  // Bundles must provide a human readable name so we can create help and error
  // messages, and the path to attach Field admin pages to.
  foreach (multifield_load_all() as $machine_name => $multifield) {
    $info['multifield']['bundles'][$machine_name] = array(
      'label' => $multifield->label,
      'admin' => array(
        'path' => 'admin/structure/multifield/list/%multifield',
        'real path' => 'admin/structure/multifield/list/' . $machine_name,
        'bundle argument' => 4,
        'access arguments' => array('administer multifield'),
      ),
    );
  }

  return $info;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function multifield_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'export_ui') {
    return 'plugins/' . $plugin;
  }
}

function multifield_load($name) {
  ctools_include('export');
  return ctools_export_crud_load('multifield', $name);
}

function multifield_load_all() {
  ctools_include('export');
  return ctools_export_crud_load_all('multifield');
}

function multifield_load_all_enabled() {
  $multifields = multifield_load_all();
  foreach ($multifields as $machine_name => $multifield) {
    if (!empty($multifield->disabled)) {
      unset($multifields[$machine_name]);
    }
  }
  return $multifields;
}

function multifield_save($multifield) {
  //$server->is_new = empty($server->sid);
  //module_invoke_all('redmine_server_presave', $server);
  ctools_include('export');
  ctools_export_crud_save('multifield', $multifield);
}

function multifield_type_save($multifield) {
  $return = NULL;
  module_invoke_all('multifield_type_presave', $multifield);

  if ($multifield->export_type & EXPORT_IN_DATABASE) {
    // Existing record.
    $return = drupal_write_record('multifield', $multifield, array('machine_name'));
    module_invoke_all('mulifield_type_update');
  }
  else {
    $multifield->export_type = EXPORT_IN_DATABASE;
    $return = drupal_write_record('multifield', $multifield, array());
    module_invoke_all('multifield_type_insert');
  }

  field_info_cache_clear();
  return $return;
}

function multifield_type_access($op, $multifield) {
  if ($op == 'edit' || $op == 'delete') {

  }
}

function multifield_type_get_fields($multifield = NULL) {
  $fields = array();
  $map = field_info_field_map();
  foreach ($map as $field_name => $field) {
    if (!empty($multifield)) {
      if ($field['type'] == $multifield->machine_name) {
        $fields[$field_name] = $field_name;
      }
    }
    else {
      if (multifield_load($field['type'])) {
        $fields[$field_name] = $field_name;
      }
    }
  }
  return $fields;
}

function multifield_delete($name) {
  if ($multifield = multifield_load($name)) {
    ctools_include('export');
    return ctools_export_crud_delete('multifield', $multifield);
  }
}

function multifield_type_delete($multifield) {
  $machine_name = is_object($multifield) ? $multifield->machine_name : $multifield;

  module_invoke_all('multifield_type_delete', $multifield);

  db_delete('multifield')
    ->condition('machine_name', $machine_name);

  field_delete_field($machine_name);
  field_info_cache_clear();
}

function multifield_type_cache_clear() {
  entity_info_cache_clear();
  field_cache_clear();
}

function multifield_field_machine_name_exists($name) {
  return field_info_field_types($name) || multifield_load($name);
}

/**
 * Implements hook_field_info().
 */
function multifield_field_info() {
  $info = array();
  $multifields = multifield_load_all_enabled();
  foreach ($multifields as $machine_name => $multifield) {
    $info[$machine_name] = array(
      'label' => $multifield->label,
      'description' => $multifield->description,
      'default_widget' => 'multifield_default',
      'default_formatter' => 'multifield_default',
    );
  }
  return $info;
}

/**
 * Implements hook_field_widget_info().
 */
function multifield_field_widget_info() {
  $info = array();
  $multifields = multifield_load_all_enabled();

  if (!empty($multifields)) {
    $info['multifield_default'] = array(
      'label' => t('Default'),
      'field types' => array_keys($multifields),
    );
  }

  return $info;
}

function multifield_field_get_field_names($machine_name = NULL) {
  $fields = &drupal_static(__FUNCTION__);

  if (!isset($fields)) {
    foreach (field_info_field_map() as $field_name => $field) {
      if (!empty($field['bundles']['multifield'])) {
        foreach ($field['bundles']['multifield'] as $bundle) {
          if (!isset($fields[$bundle])) {
            $fields[$bundle] = array();
          }
          $fields[$bundle][] = $field_name;
        }
      }
    }
  }

  if (isset($machine_name)) {
    return !empty($fields[$machine_name]) ? $fields[$machine_name] : array();
  }
  else {
    return $fields;
  }
}

/**
 * Implements hook_field_load().
 */
function multifield_field_load($entity_type, $entities, $field, $instances, $langcode, &$items, $age) {
  foreach (multifield_field_get_field_names($field['type']) as $field_name) {
    $subfield = field_info_field($field_name);
    foreach (array_keys($subfield['columns']) as $column) {
      foreach ($entities as $id => $entity) {
        foreach ($items[$id] as $delta => $item) {
          if (array_key_exists($field_name . '_' . $column, $item)) {
            $items[$id][$delta][$field_name][LANGUAGE_NONE][0][$column] = $item[$field_name . '_' . $column];
            unset($items[$id][$delta][$field_name . '_' . $column]);
          }
        }
      }
    }

    // Once the subfields have been imploded into a proper structure, we need
    // to filter out 'empty' values.
    foreach (array_keys($entities) as $id) {
      foreach ($items[$id] as $delta => $item) {
        if (!empty($item[$field_name][LANGUAGE_NONE])) {
          $items[$id][$delta][$field_name][LANGUAGE_NONE] = _field_filter_items($subfield, $item[$field_name][LANGUAGE_NONE]);
        }
      }
    }
  }

  $pseudo_entities = array();
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => &$item) {
      $pseudo_entity = _multifield_field_item_to_entity($field['type'], $item);
      $pseudo_entities[$pseudo_entity->id] = $pseudo_entity;
      $item['#pseudo_entity'] = $pseudo_entity;
    }
  }

  // Invoke field-type module's hook_field_load().
  $options = array();
  $null = NULL;
  _field_invoke_multiple('load', 'multifield', $pseudo_entities, $age, $null, $options);

  // Invoke hook_field_attach_load(): let other modules act on loading the
  // entity.
  module_invoke_all('field_attach_load', 'multifield', $pseudo_entities, $age, $options);
}

function multifield_filter_empty_subfields($items, $machine_name) {
  foreach (multifield_field_get_field_names($machine_name) as $field_name) {
    if (!empty($items[$field_name])) {
      $field = field_info_field($field_name);
      $items = _field_filter_items($subfield, $items);
    }
  }
  return $item;
}

/**
 * Implements hook_field_validate().
 */
function multifield_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $item) {
    $pseudo_entity = _multifield_field_item_to_entity($field['type'], $item);
    field_attach_validate('multifield', $pseudo_entity);
  }
}

/**
 * Implements hook_field_presave().
 */
function multifield_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  // Serialize the multifield values into separate columns for saving into the
  // field table.
  foreach (field_info_instances('multifield', $field['type']) as $field_name => $instance) {
    $subfield = field_info_field($field_name);
    foreach ($items as $delta => $item) {
      if (!empty($item[$field_name][LANGUAGE_NONE])) {
        foreach ($item[$field_name][LANGUAGE_NONE][0] as $column => $value) {
          $items[$delta][$field_name . '_' . $column] = $value;
        }
      }
      else {
        foreach ($subfield['columns'] as $column => $details) {
          $items[$delta][$field_name . '_' . $column] = isset($details['default']) ? $details['default'] : NULL;
        }
      }
    }
  }
}

function multifield_field_attach_submit($entity_type, $entity, $form, $form_state) {
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  foreach (field_info_instances($entity_type, $bundle) as $field_name => $instance) {
    $field = field_info_field($field_name);
    if ($multifield = multifield_load($field['type']) && !empty($entity->{$field_name})) {
      foreach ($entity->{$field_name} as $langcode => $items) {
        foreach ($items as $delta => $item) {
          //$pseudo_entity = _multifield_field_item_to_entity($field['type'], $item);
          //field_attach_submit('multifield', $pseudo_entity, $form, $form_state);
          //$entity->{$field_name}[$langcode][$delta] = $item;
        }
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 */
function multifield_field_is_empty($item, $field) {
  $instances = field_info_instances('multifield', $field['type']);
  foreach ($instances as $field_name => $instance) {
    if (!empty($item[$field_name])) {
      $subfield = field_info_field($field_name);
      foreach ($item[$field_name] as $langcode => $subfield_items) {
        $item[$field_name][$langcode] = _field_filter_items($subfield, $subfield_items);
      }
      $item[$field_name] = array_filter($item[$field_name]);
    }
  }
  return !array_filter(array_intersect_key($item, $instances));
}

/**
 * Implements hook_field_widget_form().
 */
function multifield_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  $item = isset($items[$delta]) ? $items[$delta] : array();

  $element['#parents'] = array_merge($element['#field_parents'], array($element['#field_name'], $element['#language'], $element['#delta']));
  $pseudo_entity = _multifield_field_item_to_entity($field['type'], $item);

  // Rather than calling field_attach_form() here, we have to limit these
  // sub-field widgets to only one cardinality value. So manually invoke
  // field_default_form() for each one.
  foreach (field_info_instances('multifield', $field['type']) as $field_name => $instance) {
    $subfield = field_info_field($field_name);
    $subfield['cardinality'] = 1;
    if ($instance['required'] && $delta > 0) {
      $instance['required'] = 0;
    }
    $subitems = isset($pseudo_entity->{$field_name}[LANGUAGE_NONE]) ? $pseudo_entity->{$field_name}[LANGUAGE_NONE] : array();
    $element += field_default_form('multifield', $pseudo_entity, $subfield, $instance, $langcode, $subitems, $element, $form_state, 0);
  }
  //field_attach_form('multifield', $pseudo_entity, $element, $form_state, $langcode);

  // If this multifield itself has a cardinality of one value, and this is not
  // being used for the field default value form, then set the wrapping element
  // to be a fieldset for display/grouping purposes.
  if ($field['cardinality'] == 1 && !empty($element['#entity'])) {
    $element['#type'] = 'fieldset';
  }

  return $element;
}

function multifield_widget_value($element, $input = FALSE, $form_state) {
  //dpm($element);
  //dpm($input);
  //dpm($form_state);
  if ($input) {
  }

  return array();
}

/**
 * Implements hook_field_formatter_view().
 */
function multifield_field_formatter_info() {
  $info = array();
  $multifields = multifield_load_all_enabled();

  if (!empty($multifields)) {
    $info['multifield_default'] = array(
      'label' => t('Default'),
      'field types' => array_keys($multifields),
      'settings' => array(
        'view_mode' => 'default',
      ),
    );
  }

  return $info;
}

/**
 * Implements hook_field_formatter_settings().
 */
function multifield_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $entity_info = entity_get_info('multifield');
  $options = array();
  foreach ($entity_info['view modes'] as $view_mode_name => $view_mode) {
    $options[$view_mode_name] = $view_mode['label'];
  }

  $element['view_mode'] = array(
    '#type' => 'select',
    '#title' => t('View mode'),
    '#options' => array('default' => t('Default')) + $options,
    '#default_value' => $settings['view_mode'],
    '#required' => TRUE,
  );

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function multifield_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $entity_info = entity_get_info('multifield');
  $view_mode_label = $settings['view_mode'] == 'default' ? t('Default') : $entity_info['view modes'][$settings['view_mode']]['label'];

  $summary = t('View mode: @view-mode', array('@view-mode' => $view_mode_label));

  return $summary;
}

/**
 * Implements hook_field_formatter_view().
 */
function multifield_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  foreach ($items as $delta => $item) {
    $element[$delta] = field_attach_view('multifield', $item['#pseudo_entity'], $settings['view_mode'], $langcode);
  }

  return $element;
}

function _multifield_field_item_to_entity($machine_name, array &$item) {
  $seen_ids = &drupal_static(__FUNCTION__, array());
  do {
    $id = mt_rand();
  }
  while (isset($seen_ids[$id]));
  $seen_ids[$id] = TRUE;

  $entity = new stdClass();
  $entity->id = $id;
  $entity->type = $machine_name;
  foreach ($item as $field => $values) {
    $entity->{$field} = &$item[$field];
  }

  return $entity;
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_overview_form().
 */
function multifield_form_field_ui_field_overview_form_alter(&$form, &$form_state) {
  // Prevent multifields from being added to multifields themselves.
  if ($form['#entity_type'] == 'multifield') {
    $form['fields']['_add_new_field']['type']['#options'] = array_diff_key($form['fields']['_add_new_field']['type']['#options'], multifield_load_all());
    $form['fields']['_add_existing_field']['field_name']['#options'] = array_diff_key($form['fields']['_add_existing_field']['field_name']['#options'], multifield_type_get_fields());
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_edit_form().
 */
function multifield_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  // Show a notice that multifield subfields have a cardinality of one value
  // enforced in the widget.
  if ($form['#instance']['entity_type'] == 'multifield') {
    $form['field']['cardinality']['#disabled'] = TRUE;
    $form['field']['cardinality']['#field_prefix'] = '<div class="messages warning">' . t('Field cardinality in multifields is limited to one value despite this setting.') . '</div>';
  }
}
